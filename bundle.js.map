{"version":3,"sources":["node_modules/browser-pack/_prelude.js","front/js/app.js","front/js/display.js","front/js/shape.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var Display = require('./display');\nvar Shape = require('./shape');\n\nfunction WebTris() {\n\n    var TILE_RATIO = 20,  // Size of blocks/tiles\n        SMALL_TILE_RATIO = 10,  // Next tile screen on the right\n        GAME_SPEED = 250, // MS between redraws\n        SHAPE_DROP_GAME_SPEED = 16, // Top speed, when dropping\n        SHAPE_LANDING_GAME_SPEED = 150, // Allows for a small delay before shape anchored\n        SHAPE_ANIMATING_SPEED = 350, // length of line drop animation\n        STEP_POINTS = 1, // Points gained by having the shape move one game revolution down\n        ALT_STEP_POINTS = 5, // Points gained for faster game revolution\n        LINE_CLEAR_POINTS = 50, // Points gained for clearing a single line\n        DISPLAY_SIZE = {x:220, y:380}, \n        SMALL_DISPLAY_SIZE = {x:50, y:50},\n        DISPLAY_ORIGIN = {x:100, y:0},\n        SMALL_DISPLAY_ORIGIN = {x:10, y:10};\n\n    var mainDisplay = new Display(document.getElementById('main-canvas'), TILE_RATIO, DISPLAY_SIZE, DISPLAY_ORIGIN),\n        secondaryDisplay = new Display(document.getElementById('secondary-canvas'), TILE_RATIO, DISPLAY_SIZE, DISPLAY_ORIGIN),\n        nextDisplay = new Display(document.getElementById('next-shape-canvas'), SMALL_TILE_RATIO, SMALL_DISPLAY_SIZE, SMALL_DISPLAY_ORIGIN),\n        pointsEl = document.getElementById('points-value'),\n        currentShape,\n        nextShape,\n        pastShapes = [],\n        points = 0;\n\n    var self = this;\n\n    this.init = function() {\n      this.assignControls();\n      this.stepNextShape();\n      this.startAnimation();\n    }\n\n    this.assignControls = function() {\n      document.onkeydown = checkKey;\n      function checkKey(e) {\n        if (e.keyCode == '38') {\n          self.moveShape('rotate');\n        } else if (e.keyCode == '32') {\n          self.beginDrop();\n        } else if (e.keyCode == '37') {\n          self.moveShape('left');\n        } else if (e.keyCode == '39') {\n          self.moveShape('right');\n        }\n      }\n\n      var leftBtn   = document.getElementsByClassName('move-left-btn')[0];\n      var rightBtn  = document.getElementsByClassName('move-right-btn')[0];\n      var rotateBtn = document.getElementsByClassName('rotate-btn')[0];\n      var dropBtn   = document.getElementsByClassName('drop-btn')[0];\n      var menuBtn   = document.getElementsByClassName('menu-btn')[0];\n      var resumeBtn = document.getElementsByClassName('resume-btn')[0];\n      var restartBtn  = document.getElementsByClassName('restart-btn')[0];\n\n      leftBtn.addEventListener('touchstart', function(){self.moveShape('left')}, false);\n      rightBtn.addEventListener('touchstart', function(){self.moveShape('right')}, false);\n      rotateBtn.addEventListener('touchstart', function(){self.moveShape('rotate')}, false);\n      dropBtn.addEventListener('touchstart', function(){self.beginDrop()}, false);\n      menuBtn.addEventListener('touchstart', function(){self.openMenu()}, false);\n      menuBtn.addEventListener('click', function(){self.openMenu()}, false);\n      resumeBtn.addEventListener('touchstart', function(){self.resumeGame()}, false);\n      resumeBtn.addEventListener('click', function(){self.resumeGame()}, false);\n      restartBtn.addEventListener('touchstart', function(){self.restartGame()}, false);\n      restartBtn.addEventListener('click', function(){self.restartGame()}, false);\n\n    }\n\n    this.openMenu = function() {\n      window.cancelAnimationFrame(self.animReq);\n      self.showModal();\n    }\n\n    this.resumeGame = function() {\n      self.hideModal();\n      self.startAnimation();\n    }\n\n    this.restartGame = function() {\n      pastShapes = [];\n      currentShape = null;\n      mainDisplay.clearDisplay();\n      secondaryDisplay.clearDisplay();\n      this.resetPoints();\n      self.stepNextShape(); \n      self.resumeGame();\n    }\n\n    this.showModal = function() {\n      var modalOverlay = document.getElementsByClassName('modal-overlay')[0];\n      var modalContainer = document.getElementsByClassName('modal-container')[0];\n      modalOverlay.className = modalOverlay.className.replace(/hidden/,'');\n      modalContainer.className = modalContainer.className.replace(/hidden/,'');\n    }\n\n    this.hideModal = function() {\n      var modalOverlay = document.getElementsByClassName('modal-overlay')[0];\n      var modalContainer = document.getElementsByClassName('modal-container')[0];\n      modalOverlay.className = modalOverlay.className + ' hidden';\n      modalContainer.className = modalContainer.className + ' hidden';\n    }\n\n    this.getHighScore = function() {\n\n    }\n\n    this.startAnimation = function() {\n      var running = true,\n          timeAtLastLoop,\n          timeAtLastRender;\n\n      function animLoop(timeSinceFirstFrame) {\n        timeAtLastLoop = Date.now();\n        if(!timeAtLastRender) timeAtLastRender = timeAtLastLoop;\n        render(timeSinceFirstFrame);\n      }\n\n      function render(timeSinceFirstFrame) {\n        if(timeAtLastLoop - timeAtLastRender > self.getGameSpeed()) {\n          timeAtLastRender = timeAtLastLoop;\n          self.moveShape('down');\n        }\n\n        //if(timeSinceFirstFrame < 60000) {\n          self.animReq = window.requestAnimationFrame(animLoop);\n        //}\n      }\n\n      self.animReq = window.requestAnimationFrame(animLoop);\n    }\n\n    this.beginDrop = function() {\n      currentShape._isDropping = true;\n    }\n\n    this.getGameSpeed = function() {\n      var speed = GAME_SPEED;\n      if(currentShape._isDropping) {\n        speed = SHAPE_DROP_GAME_SPEED;\n      } else if(currentShape._isLanding) {\n        speed = SHAPE_LANDING_GAME_SPEED;\n      } else if(currentShape._isAnimating) {\n        speed = SHAPE_ANIMATING_SPEED;\n      }\n      return speed;\n    }\n\n    this.moveShape = function(direction) {\n      var newOrigin = { x:currentShape._origin.x, y:currentShape._origin.y },\n          newTiles = currentShape._tiles,\n          bor,\n          col,\n          linesCleared,\n          shapeTemp,\n          pastShapesTemp;\n\n      if(direction === 'down') {\n        newOrigin.y += TILE_RATIO;\n        this.updatePoints();\n      } else if(direction === 'left') {\n        newOrigin.x -= TILE_RATIO;\n      } else if(direction === 'right') {\n        newOrigin.x += TILE_RATIO;\n      } else if(direction === 'rotate') {\n        newTiles = currentShape.getRotationTiles();\n      }\n\n      borderCol = this.borderCollision(newOrigin, newTiles);\n      shapeCol = this.shapeCollision(newOrigin, newTiles);\n\n      if(!borderCol && !shapeCol) {\n        mainDisplay.clearDisplay();\n        currentShape._origin = newOrigin;\n        currentShape._tiles = newTiles;\n        mainDisplay.drawShape(currentShape);\n      } else if (borderCol === 'bottom' || (direction === 'down' && shapeCol === true) ) {\n\n          pastShapesTemp  = JSON.parse(JSON.stringify(pastShapes));\n          shapeTemp       = JSON.parse(JSON.stringify(currentShape));\n          pastShapesTemp.push(shapeTemp);\n          var linesObj    = this.linesToClear(pastShapesTemp, shapeTemp._origin, shapeTemp._tiles);\n\n\n          if(currentShape._isDropping && !linesObj.linesCleared.length) {\n            currentShape._isDropping = false;\n            currentShape._isLanding = true;\n          } else if (!currentShape._isAnimating && linesObj.linesCleared.length) {\n              this.animateLineClear(linesObj.linesCleared);\n              currentShape._isDropping = false;\n              currentShape._isLanding = false;\n              currentShape._isAnimating = true;\n          } else {\n            pastShapes = pastShapesTemp;\n            secondaryDisplay.clearDisplay();\n            mainDisplay.clearDisplay();\n            this.redrawSecondaryDisplay();\n            this.updatePoints(linesObj.linesCleared.length);\n            this.stepNextShape();\n            mainDisplay.drawShape(currentShape);    \n          }\n      }\n    }\n\n    this.stepNextShape = function() {\n      if(!currentShape) {\n        currentShape = new Shape(mainDisplay._drawingOrigin);\n        mainDisplay.drawShape(currentShape);\n      } else {\n        currentShape = nextShape;\n      }\n      nextShape = new Shape(mainDisplay._drawingOrigin);\n      nextDisplay.clearDisplay();\n      nextDisplay.drawShape(nextShape, true);\n    }\n\n    this.resetPoints = function() {\n      points = 0;\n      this.updateUIpoints();\n    }\n\n    this.updatePoints = function(linesCleared) {\n      if(linesCleared) {\n        points += linesCleared * LINE_CLEAR_POINTS;\n      } else {\n        if(this.getGameSpeed() === SHAPE_DROP_GAME_SPEED) {\n          points += ALT_STEP_POINTS;\n        } else {\n          points += STEP_POINTS;\n        }\n      }\n      this.updateUIpoints();\n    }\n\n    this.updateUIpoints = function() {\n      var pointsString = points.toString();\n      while (pointsString.length < 6) {\n        pointsString = '0'+pointsString;\n      }\n      pointsEl.innerHTML = pointsString;\n    }\n\n    this.shapeCollision = function(origin, tiles) {\n      for(var i = 0; i < pastShapes.length; i++) {\n        var pShape = pastShapes[i];\n\n        for(var j = 0; j < pShape._tiles.length; j++) {\n          var pTile = pShape._tiles[j];\n          var pastX = pShape._origin.x + pTile.x*TILE_RATIO;\n          var pastY = pShape._origin.y + pTile.y*TILE_RATIO;\n\n          for(var k = 0; k < tiles.length; k++) {\n            var newX = origin.x + tiles[k].x*TILE_RATIO;\n            var newY = origin.y + tiles[k].y*TILE_RATIO;\n            if(pastX == newX && pastY == newY ) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    this.borderCollision = function(origin, tiles) {\n      var colLeft = 0;\n      var colRight = 0;\n      var colTop = 0;\n      var colBottom = 0;\n\n      for (var i = 0; i < tiles.length; i++) {\n        var left    = origin.x + tiles[i].x*TILE_RATIO;\n        var right   = origin.x + tiles[i].x*TILE_RATIO + TILE_RATIO;\n        var top     = origin.y + tiles[i].y*TILE_RATIO;\n        var bottom  = origin.y + tiles[i].y*TILE_RATIO + TILE_RATIO;\n\n        if(left < 0 && left < colLeft) {\n          colLeft = left;\n        }\n        if(right > DISPLAY_SIZE.x && right > colRight) {\n          colRight = right;\n        }\n        if(left < 0 && left < colLeft) {\n          colLeft = left;\n        }\n        if(bottom > DISPLAY_SIZE.y && bottom > colBottom) {\n          colBottom = bottom;\n        }\n      }\n\n      if(colRight > 0 || colLeft < 0) {\n        return 'sides';\n      } else if (colBottom > 0) {\n        return 'bottom';\n      }\n    }\n\n    this.linesToClear = function(shapesArr, origin, tiles) {\n      //get affected lines\n      var lines = [];\n      var maxTilesInLine = Math.floor(DISPLAY_SIZE.x / TILE_RATIO);\n      var linesCleared = [];\n\n      // mark the lines affected by current landed shape tiles\n      for (var i = 0; i < tiles.length; i++) {\n        var lineExists = false;\n        for (var j = 0; j < lines.length; j++) {\n         if(origin.y+tiles[i].y*TILE_RATIO === lines[j].lineY) lineExists = true;\n        }\n        if(!lineExists) {\n          var myObj = {lineY: origin.y+tiles[i].y*TILE_RATIO, tilesInLine:0};\n          lines.push(myObj);\n        }\n      }\n\n      // iterate all the shapes and their tiles, count tiles in each marked line (more efficient than checking all shapes)\n      for (var i = 0; i < shapesArr.length; i++) {\n        for(var j = 0; j < shapesArr[i]._tiles.length; j++) {\n          var tileY = shapesArr[i]._origin.y + shapesArr[i]._tiles[j].y*TILE_RATIO;\n\n          for (var k = 0; k < lines.length; k++) {\n           if(tileY === lines[k].lineY) {\n             lines[k].tilesInLine++;\n           }\n          }\n        }\n      }\n\n      // erase tiles from full lines, update rest of other tiles' Y to be a line lower\n      for (var i = 0; i < lines.length; i++) {\n\n        if(lines[i].tilesInLine === maxTilesInLine) {\n          var eraseY = lines[i].lineY;\n          linesCleared.push(lines[i]);\n\n          for (var j = 0; j < shapesArr.length; j++) {\n            var k = shapesArr[j]._tiles.length;\n\n            while(k--) {\n              var tileY = shapesArr[j]._origin.y + shapesArr[j]._tiles[k].y*TILE_RATIO;\n\n              if(tileY < eraseY) {\n                shapesArr[j]._tiles[k].y += 1;\n              }\n              else if (tileY === eraseY){\n                shapesArr[j]._tiles.splice(k,1);\n              }\n            }\n          }\n        }\n\n      }\n\n      return {shapesArr:shapesArr, linesCleared:linesCleared};\n    }\n\n    this.animateLineClear = function(linesCleared) {\n    var alpha = 0;\n    var ctx = mainDisplay._ctx;\n    var interval = setInterval(function () {\n            ctx.fillStyle = \"rgba(255, 255, 255, \" + alpha + \")\";\n            ctx.fillRect(0, linesCleared[0].lineY, mainDisplay._size.x, linesCleared.length*TILE_RATIO);\n            alpha = alpha + 0.1; \n            if (alpha >= 1) {\n                clearInterval(interval);\n            }\n        }, 25); \n\n    }\n\n    this.redrawSecondaryDisplay = function() {\n      secondaryDisplay.clearDisplay();\n      secondaryDisplay.drawShapes(pastShapes);\n    }\n\n}\n\nwindow.onload = function(){\n  var game = new WebTris();\n      game.init();\n}\n","function Display(canvasEl, tileRatio, size, drawingOrigin) {\n  // initing draw scrrren\n  this._canvasEl = canvasEl;\n  this._tileRatio = tileRatio;\n  this._size = size;\n  this._drawingOrigin = drawingOrigin;\n\n  // inittin our draw area\n  this._canvasEl.setAttribute('width', this._size.x);\n  this._canvasEl.setAttribute('height', this._size.y);\n\n  // setting the context\n  this._ctx = this._canvasEl.getContext('2d');\n}\n\n\nDisplay.prototype.clearDisplay = function() {\n  this._ctx.clearRect(0,0,this._canvasEl.width, this._canvasEl.height);\n}\n\n\nDisplay.prototype.drawShape = function(shape, useDisplayOrigin){\n  var tiles = shape._tiles,\n      origin,\n      ctx = this._ctx;\n\n  if (useDisplayOrigin){ \n    origin = this._drawingOrigin;\n  } else {\n    origin = shape._origin;\n  }\n\n  ctx.fillStyle = shape._color;\n\n  for (var i = 0; i < tiles.length; i++) {\n    ctx.fillRect(\n      origin.x + tiles[i].x*this._tileRatio,\n      origin.y + tiles[i].y*this._tileRatio,\n      this._tileRatio,\n      this._tileRatio);\n\n    var tileStartX  = origin.x + tiles[i].x*this._tileRatio;\n    var tileStartY  = origin.y + tiles[i].y*this._tileRatio;\n\n    ctx.strokeStyle='white';\n    ctx.lineWidth = 2;\n\n    ctx.beginPath();\n    ctx.moveTo(tileStartX, tileStartY);\n    ctx.lineTo(tileStartX+this._tileRatio, tileStartY);\n    ctx.lineTo(tileStartX+this._tileRatio, tileStartY+this._tileRatio);\n    ctx.lineTo(tileStartX+this._tileRatio, tileStartY+this._tileRatio);\n    ctx.lineTo(tileStartX, tileStartY+this._tileRatio);\n    ctx.closePath();\n    ctx.stroke();\n\n  }\n\n}\n\n\nDisplay.prototype.drawShapes = function(shapes){\n    for(var i = 0; i < shapes.length; i++) {\n      this.drawShape(shapes[i]);\n    }\n}\n\nmodule.exports = Display;","function Shape(origin, tileRatio) {\n  var allShapes = [\n  {\n    type:  'line',\n    color: 'blue',\n    tiles: [{x:1, y:0}, {x:1, y:1},{x:1, y:2},{x:1, y:3}]\n  },\n  {\n    type:  'square',\n    color: 'green',\n    tiles: [{x:0, y:0}, {x:1, y:0}, {x:1, y:1}, {x:0, y:1}]\n  },\n  {\n    type:  'plus',\n    color: 'red',\n    tiles: [{x:1, y:0}, {x:0, y:1}, {x:1, y:1}, {x:2, y:1}]\n  },\n  {\n    type:  'rightL',\n    color: 'yellow',\n    tiles: [{x:1, y:0}, {x:1, y:1}, {x:1, y:2}, {x:2, y:2}]\n  },\n  {\n    type:  'leftL',\n    color: 'orange',\n    tiles: [{x:1, y:0}, {x:1, y:1}, {x:1, y:2}, {x:0, y:2}]\n  },\n  {\n    type:  'rightS',\n    color: 'gray',\n    tiles: [{x:0, y:0}, {x:0, y:1}, {x:1, y:1}, {x:1, y:2}]\n  },\n  {\n    type:  'leftS',\n    color: 'black',\n    tiles: [{x:1, y:0}, {x:1, y:1}, {x:0, y:1}, {x:0, y:2}]\n  }];\n\n  var randomShape = allShapes[allShapes.length * Math.random() << 0];\n  this._color = randomShape.color;\n  this._tiles = JSON.parse(JSON.stringify(randomShape.tiles));\n  this._isDropping = false;\n  this._isLanding = false;\n  this._isAnimating = false;\n  this._origin = origin || {x: 0, y: 0};\n  \n  if(tileRatio){ //make Y the same so it'll fit nicely when emerges from the top\n    var topY;\n    this._tiles.forEach(function(tile){\n      if(!topY || topY < tile.y) {\n        topY = tile.y;\n      }\n    });\n    this._origin.y = ((3-topY)*tileRatio + 4*-tileRatio);\n    console.log(this._origin.y);\n  }\n\n}\n\nShape.prototype.getRotationTiles = function () {\n    var tiles = [];\n    for (var i = 0; i < this._tiles.length; i++) {\n      var tilex = this._tiles[i].x;\n      var tiley = this._tiles[i].y;\n      tiles[i] = {};\n      tiles[i].x = 2 - tiley;\n      tiles[i].y = tilex;\n      //x2 = px + (x1-px)*cos(q)-(y1-py)*sin(q);\n      //y2 = py + (x1-px)*sin(q)+(y1-py)*cos(q);\n    }\n    return tiles;\n}\n\nmodule.exports = Shape;"]}